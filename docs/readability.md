# 데일리FE팀은 수정하기 쉽고 가독성이 높은 짧은 코드를 지향합니다.

## Readability 사전적 정의

1. 재미있게 읽을 수 있음
2. 읽기 쉬움

## 코드의 가독성이 높아야 하는 이유

### 1. 수정하기 쉽다.

> 수정하기 쉬운 코드 by 리팩토링 1.10 마치며
>
> - 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.
> - 코드를 수정해야할 상황이 되면 고쳐야 할 곳을 쉽게 찾을 수 있고 오류 없이 빠르게 수정할 수 있어야 한다. 건강한 코드베이스는 생산성을 극대화하고, 고객에게 필요한 기능을 더 빠르고 저렴한 비용으로 제공하도록 해준다.
> - 코드를 수정하려면 사람이 개입되고 설계가 나쁜 시스템은 수정하기 어렵다. 원하는 동작을 수행하도록 하기위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 간구하기가 어렵기 때문이다.
> - 무엇을 수정할지 찾기 어렵다면 실수를 저질러서 버그가 생길 가능성도 높아진다.

### 2. 지속 가능한 개발환경

> 전체 다 합치면 무려 700페이지가 넘는 분량입니다. 이렇게 방대한 프레젠테이션을 작성하게 된 이유는 저희 팀을 보다 ‘지속 가능한 개발을 할 수 있는 환경으로 만들고 싶다’라는 마음 때문이었습니다.
>
> 2011년에 LINE 개발을 시작한 이후 더 좋은 사용자 체험을 제공하기 위해 끊임없이 기능 개발과 개선을 해왔습니다. 그렇게 서서히 프로젝트가 성장한 결과 Android 클라이언트 코드는 모듈을 포함하면 150만 행까지 늘어났고, 팀은 50명을 넘는 규모가 되었습니다. 하지만 특정 누군가가 계속 리팩터링하는 것만으로는 이런 환경을 구현할 수 없습니다.
>
> 거대한 프로젝트에서는 ‘코드 가독성 유지와 기술 부채의 지속적인 상환’ 자체를 확장 가능한(scalable) 상태로 만들어야 합니다. 즉, 개발에 관여하는 멤버 모두가 가독성과 기술 부채를 신경 쓸 필요가 있습니다. 가독성 높은 코드를 작성하는 것은 단순하게 기능을 구현하는 일보다 어려움이 많습니다. 이를 위해서는 어떤 코드가 잘 읽히는지에 관한 지식과 효율적으로 프로그램의 구조를 재구성하는 기술이 필요합니다.
> https://engineering.linecorp.com/ko/blog/code-readability-vol1/

## 어떤 코드가 가독성이 높은 코드인가?

- 모든 수정은 필요한 부분만 고치는것이 아니라 처음 작업하기 전보다 더 나아진 코드로 리팩토링 합니다.

> Boy scout rule by 리팩토링 1.7 중간점검
>
> 프로그래밍에서만큼은 명료함이 진화할 수 있는 소프트웨어의 정수다. 모듈화한 덕분에 계산 코드를 중복하지 않고도 HTML 버전을 만들 수 있었다.
> 출력 로직을 더 간결하게 만들 수 도 있지만 일단은 이 정도에서 멈추겠다.
> 나는 항상 리팩터링과 기능 추가 사이의 균형을 맞추려고 한다.
> 항시 코드베이스를 작업하기 전보다 더 건강하게 고친다라는 캠핑 규칙을 적용한다.
> 완벽하지는 않더라도, 분명 더 나아지게 한다.

### 짧은 코드

> 짧은 코드 유지 by 리팩토링 3.3 긴 함수 (Long Function)
>
> - 경험에 비춰보면 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다.
> - 예전 언어는 서브루틴을 호툴하는 비용이 컸기 때문에 짧은 함수를 꺼렸다. 하지만 요즘 언어는 프로세스 안에서의 함수 호출 비용을 거의 없애버렸다.
> - 짧은 함수로 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. 그러기 위해서는 훨씬 적극적으로 함수를 쪼개야 한다.
> - 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 함수로 묶는 코드는 여러 줄일 수 도 있고 단 한 줄일 수도 있다. 심지어 원래 코드보다 길어지더라도 함수로 뽑는다. 단, 함수 이름에 코드의 목적을 드러내야 한다.

### 중복코드

> 중복코드 보다 가독성 by 리팩토링 1.4 statement() 함수 쪼개기
>
> - 반복문이 중복되는 것을 꺼리는 이들이 많지만, 이 정도 중복은 성능에 미치는 영향이 미미할 때가 많다. 실제로 리팩터링 전과 후의 실행 시간을 측정해보면 차이를 거의 느끼지 못할 것이다. 경험 많은 프로그래머조차 코드의 실제 성능을 정확히 예측하지 못한다.
> - 똑똑한 컴파일러들은 최신 캐싱 기법 등으로 무장하고 있어서 우리의 직관을 초월하는 결과를 내어주기 때문이다.
> - 리팩터링으로 인한 성능 문제에 대한 내 조언은 '특별한 경우가 아니라면 일단 무시하라'는 것이다. 리팩터링 때문에 성능이 떨어진다면, 하던 리팩터링을 마무리하고 나서 성능을 개선하자.

> 성급한 추상화 보다 중복코드가 낫다 by https://365kim.tistory.com/77
>
> 우리는 미래에 대해 알 수 없기 때문에 우리가 실제로 최적화해야 할 것은 변경사항입니다.
> Sandi Mintz는 '중복은 잘못된 추상화보다 비용이 낮다.
> 그러므로 잘못된 추상화보다는 중복을 선호하자.'라고 말했습니다.

> 최적화 보다 가독성 by [좋은 코딩을 위한 13 가지 간단한 규칙](https://mingrammer.com/translation-13-simple-rules-for-good-coding/)
>
> - 코드는 항상 읽기 쉽고 개발자들이 이해할 수 있게끔 작성하라. 읽기 어려운 코드를 읽는데 소모되는 시간과 비용은 최적화로부터 얻을 수 있는 것보다 더욱 크다. 최적화가 필요하다면, DI (의존성 주입)을 사용해 독립적인 모듈로 만들고, 100%의 테스트 커버리지를 유지하여 최소 1년간은 건들지 않아도 되도록 만들어라.

또 우리는 미래에 대해 알 수 없기 때문에 우리가 실제로 최적화해야 할 것은 변경사항입니다. Sandi Mintz는 '중복은 잘못된 추상화보다 비용이 낮다. 그러므로 잘못된 추상화보다는 중복을 선호하자.'라고 말했습니다.

- 개발 담당자가 변경될 경우 기존 히스토리를 몰라도 빠르게 파악할 수 있는 코드 베이스를 유지합니다.
- 언제든 변경이 될 수 있다라는 가정하에 개발을 진행합니다.
- 2개 이상 페이지에서 사용하는 컴포넌트, 함수를 공통화할 경우 1개 페이지에서 수정사항이 발생하면 2개 이상의 페이지에 영향을 미치게 됩니다.
- 히스토리를 알고 있는 개발자는 금방 수정이 가능하지만, 개발 담당자가 변경이 되면 영향도를 파악하는데 시간이 오래 걸리게 되고 버그가 생길 가능성도 높아지게 됩니다.
- 공통화를 진행하는 경우는 디자인 시스템에 등록되는 컴포넌트나 어플리케이션 전체에서 사용하는 기능으로 제한하며 SD 와 논의후 수정,추가, 삭제 진행을 합니다.

- 짧은 코드를 유지합니다.

  - 1개의 파일은 100줄, 1개의 함수는 30줄이 넘어가면 리팩토링을 통해 짧은 코드로 수정합니다.

- 팀 내부 논의없이 어떠한 배포를 하지 않습니다.
- 기존 레거시 코드와 로직은 잘못 작성된 코드들이 많이 있습니다.
  - 기존 개발 방식대로 사용을 한다거나, 기존 로직 대로 개발하면 안됩니다.
  - 기존 개발 방식과 로직이 맞는지 PO, BE 개발자들과 검증 후 신규개발/수정을 진행해야 합니다.
- 다른 팀원이 수정하기 쉬운 가독성 높은 코드를 작성합니다.
- 중복코드가 발생하더라도 다른 페이지, 어플리케이션 전체에 영향을 미치지 않도록 개발합니다.

  - 비슷한 페이지라고 하더라도 변경사항이 생기면 소스를 분리해야하는 경우가 많고 수정이 일어나면 영향을 받는 페이지들을 다 테스트해야되기 때문에 코드를 복사해서 수정시 영향범위를 제한 합니다.

- 모든 페이지 탭, 버튼 등은 URL로 접근 가능해야 합니다.
- 리프레시를 했을 경우 사용자가 보던 UI 상태를 유지해야 합니다.
- 앞으로가기, 뒤로가기를 했을 경우 사용자의 스크롤 포지션을 유지해야 합니다.
- iOS 12 이상 단말 확인
- Android 5 이상 단말 확인
- IE 11 이상 확인
- browser console 에서 React warning 부분 확인 후 수정
- 에러방지를 위해 객체에 항상 ?. 으로 접근해서 사용 `hotel?.room?.name`
- 최대한 페이지 리프레시를 하지 않는다. location.reload() 금지
- 안드로이드 네이버 앱에서 웹페이지 기능 검증

## References

- [Google Readability Process](https://abseil.io/resources/swe-book/html/ch03.html#readability_standardized_mentorship_thr)
